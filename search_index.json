[
["index.html", "Github actions with R Chapter 1 Introduction 1.1 What are GitHub actions? 1.2 Extensions 1.3 More information and useful links", " Github actions with R Chris Brown, Murray Cadzow, Paula A Martinez, Rhydwyn McGuire, David Neuzerling, David Wilkinson, Saras Windecker 2019-12-13 Chapter 1 Introduction 1.1 What are GitHub actions? GitHub actions allow us to trigger automated steps after we launch GitHub interactions such as when we push, pull, submit a pull request, or write an issue. For example, there are actions that will automatically trigger: continuous integration (CI) messages in response to issues or pull requests rendering/compiling eg. of bookdown, blogdowns etc GitHub actions follow the steps designated in a yaml file, which we place in the .github/workflows folder of the repo. We can add these yaml files to our repo either by clicking on a series of steps on GitHub.com, or using wrapper functions provided by the usethis package, depending on which actions you which to include. We describe both ways here. 1.1.1 usethis wrappers Jim Hester is working to add GitHub action functionalities to the development version of the usethis package. To use these functions now, you’ll need to install the development version, as follows: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;r-lib/usethis&quot;) Two specific GitHub actions related to continuous integration can be implemented with either of the following: usethis::use_github_action_check_release() usethis::use_github_action_check_full() More details at in Chapter 3. There are a range of other R actions available in the r-lib library. You can add these example yaml files using the following function (demonstrated here with the check-release action): usethis:::use_github_action(&#39;check-release.yaml&#39;) 1.1.2 Marketplace Actions There are a huge selection of other actions that you can choose from in the Marketplace that automate not only GitHub processess but also programming-language-specific options. To implement these, go to any repo you own and you will find “Actions” on the top menu. Click on “New Workflow” and pick one from the templates provided. In some cases the yaml will need to be modified. More detail on understanding the yaml files can be found at @ref(understanding_yaml). 1.2 Extensions We experimented with seting up continuous integration with a reproducible environment using renv @ref(testing_with_renev). 1.3 More information and useful links R specific GitHub actions examples from r-lib use_github_action function and similar functions help documentation Glossary of actions Workflow syntax for GitHub Actions :tada: Now you know that are GitHub actions, and where to find more information about those! Note: the r-lib/ghactions repo is deprecated! "],
["community-contributions-tada.html", "Chapter 2 Community contributions :tada:", " Chapter 2 Community contributions :tada: As part of this project some community contributions came up! Issue Spontaneous repository issues with setup-r using ubuntu-latest runner to r-lib/actions from @mdneuzerling PR export use_github_action function to r-lib/usethis from @smwindecker PR adds skip_on_gh_actions (resolves #970) to r-lib/testthat from @njtierney "],
["packageci.html", "Chapter 3 Example workflow to set up continuous integration for packages 3.1 Package setup and connect with Github 3.2 Actions for continuous integration checks", " Chapter 3 Example workflow to set up continuous integration for packages This is an example workflow to create a package and use Github actions apply continuous integration to automatically check and test packages upon a git push. Github actions are included in the dev version of usethis which can be installed from github using # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;r-lib/usethis&quot;) 3.1 Package setup and connect with Github 3.1.1 New project, Github first Follow instructions for setting up a new project with happygitwithr Create a package usethis::create_package(path = &quot;path-to-project&quot;) 3.1.2 Existing package with github Make sure that you have GitHub set up with your package. Existing project and package, github first Existing project and package, github last Before initiating GitHub actions, you’ll need to point to where your GitHub instance is located. The following function populates the URL and BugReports fields of a GitHub-using R package DESCRIPTION file with links to GitHub. If your project is hosted by an enterprise GitHub server you’ll need to modify the input arguments. usethis::use_github_links() 3.2 Actions for continuous integration checks 3.2.1 release-check This option checks your work using usethis::use_github_actions() This creates the required yaml file in .github/workflows/ for using the GitHub action that runs the release-check for a package on gitGitHubhub and includes the code to add the badge in your readme. Now git add, commit the changes and push them to your repo and the action will run! "],
["testing-with-a-reproducible-environment.html", "Chapter 4 Testing with a reproducible environment", " Chapter 4 Testing with a reproducible environment We can take testing a step further by setting up an environment that mimics the one we used to train out model, and is set up the same way each time. First we need to set up a lockfile for our package that tells R exactly what packages — including the versions — should be used to reproduce this We’ll be using the renv package, but a word of warning first: this package is still under active development, so this information may quickly become outdated. Once you’ve installed renv, open the R project containing your package and run renv::snapshot(). There will be a prompt for your consent to alter some files in your project and system. This function will automatically determine the dependencies used in your package, as well as what packages (and versions) are installed on your system, and will record this information in a lock file. When you open your project in the future, RStudio will automatically load the packages that are recorded in the snapshot, down to the version number. If the specific versions aren’t available, it will download them and install them from source, or using available binaries. Try restarting your R environment to see this happen. We can trigger this behaviour manually with renv::restore(). To learn more about the renv package, read the introductory article. Now we need to configure GitHub actions to use the snapshot we’ve just set up. In the previous action, we used macOS so that we could take advantage of available package binaries for quick installation. I’m going to be using Ubuntu for this to replicate my person Linux environment, and this means that packageres will be installed from source. Here’s the workflow that I’m using. Read through it and see if you can work out what’s going on, and then we’ll go through the finer details: on: [push, pull_request] name: R-CMD-check jobs: R-CMD-check: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v1 - uses: r-lib/actions/setup-r@master with: r-version: &#39;3.6.1&#39; - name: Install libcurl run: sudo apt-get install libcurl4-openssl-dev - name: Install renv 0.9.2 run: Rscript -e &quot;install.packages(&#39;https://cran.r-project.org/src/contrib/renv_0.9.2.tar.gz&#39;, repos = NULL, type = &#39;source&#39;)&quot; - name: Install rcmdcheck 1.3.3 run: Rscript -e &quot;install.packages(&#39;https://cran.r-project.org/src/contrib/rcmdcheck_1.3.3.tar.gz&#39;, repos = NULL, type = &#39;source&#39;)&quot; - name: Check run: Rscript -e &quot;renv::restore();rcmdcheck::rcmdcheck(args = &#39;--no-manual&#39;, error_on = &#39;error&#39;)&quot; There are a few differences with this workflow: I’ve specified a version of R to install, for better reproducibility. I’ve installing a package for the operating system, libcurl4-openssl-dev. Because we’re installing R packages from source, we need to be sure that our operating system has all of the tools it needs to compile the source files. This particular package is required to use curl within R; this is pretty important, since if you’re doing anything involving the internet, there’s a good chance you’re using curl somewhere. Your specific package may not need this, but I’m including it here as an example of how to run apt-get in GitHub Actions. We’re installing two packages individually here: renv and rcmdcheck. We need renv to restore our lockfile, so we need to specifically install it before we think about package dependencies. Finally, rcmdcheck is not (usually) a package dependency, and we need it to check our package. Note that we’re manually specifying version numbers here for reproducibility. Our final step looks a little different. We’re calling renv::restore(), which automatically handles all of our package dependencies. Then we run rcmdcheck as we did before. On Ubuntu, packages are installed from source. This is much slower; on one of my packages, testing in a reproducible environment on Ubuntu takes 35 minutes, as opposed to 4 minutes. Caching can make life easier, so let’s take a look at that now. The idea behind caching is to record our installed R packages so that, for future runs, we can have them readily available instead of installing from source. In one of my packages, caching decreased testing time from 35 minutes to 4 minutes. GitHub caches last a week, so if you push commits infrequently you may not realise the benefits of caching. We implement caching by adding two steps to the above YAML: We install and use the remotes package to determine the packages that our repository depends upon. We cache our R libraries folder, given by the R_LIBS_USER environment variable, using the hash of the dependencies as the cache key. If the package dependencies change, so too does the hash, and our cache becomes invalid. There’s a third step that GitHub handles automatically — before the job is complete, the cache is created and our installed packages are stored. On future runs, the cache is unpacked. R will see that the packages are installed and won’t install them again from source. You can read more about caching in GitHub actions in the official documentation. An example yaml file is given below: on: [push, pull_request] name: R-CMD-check jobs: R-CMD-check: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v1 - uses: r-lib/actions/setup-r@master with: r-version: &#39;3.6.1&#39; - name: Install libcurl run: sudo apt-get install libcurl4-openssl-dev - name: Query dependencies run: Rscript -e &quot;install.packages(&#39;remotes&#39;)&quot; -e &quot;saveRDS(remotes::dev_package_deps(dependencies = TRUE), &#39;depends.Rds&#39;)&quot; - name: Cache R packages if: runner.os != &#39;Windows&#39; uses: actions/cache@v1 with: path: ${{ env.R_LIBS_USER }} key: ${{ runner.os }}-r-3.6.1-${{ hashFiles(&#39;depends.Rds&#39;) }} restore-keys: ${{ runner.os }}-r-3.6.1- - name: Install renv 0.9.2 run: Rscript -e &quot;install.packages(&#39;https://cran.r-project.org/src/contrib/renv_0.9.2.tar.gz&#39;, repos = NULL, type = &#39;source&#39;)&quot; - name: Install rcmdcheck 1.3.3 run: Rscript -e &quot;install.packages(&#39;https://cran.r-project.org/src/contrib/rcmdcheck_1.3.3.tar.gz&#39;, repos = NULL, type = &#39;source&#39;)&quot; - name: Check run: Rscript -e &quot;renv::restore();rcmdcheck::rcmdcheck(args = &#39;--no-manual&#39;, error_on = &#39;error&#39;)&quot; "],
["so-whats-actually-going-on-in-the-yaml-file.html", "Chapter 5 So what’s actually going on in the yaml file? 5.1 R Syntax options", " Chapter 5 So what’s actually going on in the yaml file? Note: you can use .yml or .yaml as extension of your file for your workflow. Let’s explore the yaml code for the first issue message here: click me code name: Greetings on: [pull_request, issues] jobs: greeting: runs-on: ubuntu-latest steps: - uses: actions/first-interaction@v1 with: repo-token: ${{ secrets.GITHUB_TOKEN }} issue-message: &#39;Hi ! there!! thanks for your contribution!, you are awesome! &#39; pr-message: &#39;Hey what an input! please give us a bit of time to review it! We will be in touch soon.&#39; or here https://github.com/ropenscilabs/CIsandbox/blob/master/.github/workflows/greetings.yml. Translated that says, the workflow action name is ‘Greetings’ is triggered on pull requests and issues. It will start a job with the name greeting, and will run on a runner for the example it is called ubuntu-latest. Then, each job has steps that will set up the environment in the runner with a few options. See more about the syntax. A few examples: `on` can be `issues`, `pull`, `pull_request` you can use one or many as `[pull, pull_request]` `uses`: `actions/checkout@master` or for the first `actions/first-interaction@v1` 5.1 R Syntax options Change the on: push: name: jobs: render: name: runs-on: macOS-latest steps: - uses: actions/checkout@v1 - uses: r-lib/actions/setup-r@v1 - uses: r-lib/actions/setup-pandoc@v1 - name: run: Rscript -e ‘install.packages(“”)’ - name: run: Rscript -e ‘rmarkdown::render(“examples/README.Rmd”)’ - name: run: | git commit .md -m ‘Re-build .Rmd’ || echo “No changes to commit” git push https://${{github.actor}}:\\({{secrets.GITHUB_TOKEN}}@github.com/\\){{github.repository}}.git HEAD:${{ github.ref }} || echo “No changes to commit” The on parameter tells GitHub what should trigger this action. In this case, we want to check code whenever it is pushed, or on a pull request. The latter is particularly useful because if we’re about to merge code into the master branch, we want it to pass tests! The name of the action should be something that helps us identify at a glance what the action is doing. This is shown on github.com in the Actions tab of the repository. runs-on tells GitHub what sort of environment should run the job. These environments are called “runners”. GitHub supports Ubuntu, macOS and Windows Server, as well as support for self-hosted runners. uses allows us to run other actions as part of our action. In this case, we’re calling on actions that are defined in other repositories. The first action checks out the contents of our repository, and then next sets up R. The remaining steps are the commands we want to run as part of our action, each with a name. Here we’re installing the dependencies of our package, as well as the rcmdcheck package we use to check the package in our repository. Finally, we’re executing the command that checks the package. "]
]
